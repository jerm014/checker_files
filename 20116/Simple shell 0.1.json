{
  "id": 1034,
  "title": "Simple shell 0.1",
  "github_repo": "simple_shell",
  "github_dir": "",
  "github_file": "",
  "body": "Write a UNIX command line interpreter.\r\n\r\n- Usage: `simple_shell`\r\n\r\nYour Shell should:\r\n\r\n- Display a prompt and wait for the user to type a command. A command line always ends with a new line.\r\n- The prompt is displayed again each time a command has been executed.\r\n- The command lines are simple, no semi-columns, no pipes, no redirections or any other advanced features.\r\n- The command lines are made only of one word. No arguments will be passed to programs.\r\n- If an executable cannot be found, print an error message and display the prompt again.\r\n- Handle errors.\r\n- You have to handle the \"end of file\" condition (`Ctrl+D`)\r\n\r\nYou don't have to:\r\n\r\n- use the `PATH`\r\n- implement built-ins\r\n- handle special characters : `\"`, `'`, `` ` ``, `\\`, `*`, `&`, `#`\r\n- be able to move the cursor\r\n- handle commands with arguments\r\n\r\n```\r\njulien@ubuntu:~/shell$ ./shell \r\n#cisfun$ ls\r\n./shell: No such file or directory\r\n#cisfun$ /bin/ls\r\nbarbie_j       env-main.c  exec.c  fork.c  pid.c  ppid.c    prompt   prompt.c  shell.c\tstat.c\t\t   wait\r\nenv-environ.c  exec\t   fork    mypid   ppid   printenv  promptc  shell     stat\ttest_scripting.sh  wait.c\r\n#cisfun$ /bin/ls -l\r\n./shell: No such file or directory\r\n#cisfun$ ^[[D^[[D^[[D\r\n./shell: No such file or directory\r\n#cisfun$ ^[[C^[[C^[[C^[[C\r\n./shell: No such file or directory\r\n#cisfun$ exit\r\n./shell: No such file or directory\r\n#cisfun$ ^C\r\njulien@ubuntu:~/shell$ echo \"/bin/ls\" | ./shell\r\n#cisfun$ barbie_j       env-main.c  exec.c  fork.c  pid.c  ppid.c    prompt   prompt.c  shell.c\tstat.c\t\t   wait\r\nenv-environ.c  exec\t   fork    mypid   ppid   printenv  promptc  shell     stat\ttest_scripting.sh  wait.c\r\n#cisfun$ julien@ubuntu:~/shell$\r\n```"
}